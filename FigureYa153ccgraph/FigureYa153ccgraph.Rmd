---
title: "FigureYa153ccgraph"
author: "Chunhui Gao"
reviewer: "Ying Ge, Junyi Shen"
date: "2025-5-20"
output: html_document
---
# Academic Citation
If you use this code in your work or research, we kindly request that you cite our publication:

Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization Framework for Enhancing Biomedical Data Interpretation and Research Efficiency. iMetaMed. https://doi.org/10.1002/imm3.70005

# 需求描述
# Requirement Description

用R从形式上复现原图。
Use R to reproduce the original figure in a formal manner.

![](example.png)

出自<https://academic.oup.com/jnci/article-lookup/doi/10.1093/jnci/djy156>
From <https://academic.oup.com/jnci/article-lookup/doi/10.1093/jnci/djy156>

Figure 1. Plot of all alterations detected by plasma next-generation sequencing (n=210). Size of circles represents number of patients identified with an alteration.

**图的解析**
**Graph Analysis**

例文用来展示基因上的 SNP/Indel/CNV 突变（多态性差异）。 例如，在TP53基因中发现了最多的多态性，包括 CNV 差异 SPLICE 8 个，单核苷酸位点差异 R273H 5个等。用点的大小表示差异，所以很容易发现常见的多态性差异。
The example graph is used to display SNP/Indel/CNV mutations (polymorphic differences) within a gene. For example, the TP53 gene has the most polymorphisms, including 8 CNV differences (SPLICE) and 5 single nucleotide variations (R273H). The size of the dots represents the difference, making it easy to spot common polymorphic differences.

稍作观察便可发现，本图是一个“圆环套圆环”的布局，中心处在中央，下一级的项目分别处在外环。图中只有二环，如果要扩展成五环，多显示几个层次应该也不错。
A quick inspection reveals that this graph has a "ring within a circle" layout, with the center at the center and the next-level items on the outer rings. The diagram only has two rings. If you want to expand it to five, showing more layers would be helpful.

**原文用的是在线工具**
**The original article used an online tool**

推测原文是用这个工具画的：FuncTree<https://bioviz.tokyo/functree/>，能画出类似的图，用来展示基因组数据的关系。
It's speculated that the original article used this tool: FuncTree<https://bioviz.tokyo/functree/>, which can create similar diagrams for displaying relationships in genomic data.

缺点：输入数据格式复杂非常复杂。需要针对每一个点做有针对性的设置。感兴趣的小伙伴去尝试一下吧～
Disadvantages: The input data format is very complex. Targeted settings are required for each point. If you're interested, give it a try!

**如何用R实现**
**How to Implement This in R**

[tidytuesday](https://github.com/rfordatascience/tidytuesday)2019-11-12的图跟原图很像，代码<https://github.com/spren9er/tidytuesday/blob/master/tidytuesday_201946_cran_packages.r>，输入数据<https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-11-12/loc_cran_packages.csv>。
I found that the 2019-11-12 graph from [tidytuesday](https://github.com/rfordatascience/tidytuesday) is very similar to the original. The code is <https://github.com/spren9er/tidytuesday/blob/master/tidytuesday_201946_cran_packages.r>, and the input data is <https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-11-12/loc_cran_packages.csv>.

参考这套代码，用 `ggraph` 来画这个图。为此，花了几天时间仔细研究了`ggraph`包，写下了一篇长文：[一文读懂 ggraph
的使用](https://mp.weixin.qq.com/s/XYVW7wzJIPaHCpBR7j3coQ)
Using this code as a reference, I used `ggraph` to draw this graph. To this end, I spent several days thoroughly studying the `ggraph` package and wrote a lengthy article: [Understanding ggraph in One Article](https://mp.weixin.qq.com/s/XYVW7wzJIPaHCpBR7j3coQ)

# 应用场景
# Application Scenarios

展示层级结构。例如：
Displaying hierarchical structures. For example:

- 基因跟突变的关系，像例文那样；
- 上游调控因子调控下游基因的层级和强度；
- 宏基因组测序中发现的物种的丰度等信息。
- The relationship between genes and mutations, as in the example;
- The level and strength of upstream regulatory factors regulating downstream genes;
- Information such as the abundance of species discovered in metagenomic sequencing.

**注：**
**Note:**

- 周围点的大小只能对应正值或绝对值，不能展示正负区别；
- 不仅限于2层关系，还支持更多层级。
- The size of surrounding points can only correspond to positive or absolute values; it cannot display positive or negative differences;
- Not limited to two-level relationships; more levels are supported.

# 环境设置
# Environment Setup

加载R包
Loading the R package

```{r}
source("install_dependencies.R")
library(clusterProfiler)
library(GOplot)
library(tidyverse)
library(data.table)
library(ggraph)
library(tidygraph)
Sys.setenv(LANGUAGE = "en") #显示英文报错信息 #Display English error messages
options(stringsAsFactors = FALSE) #禁止chr转成factor #Disable conversion of chr to factor
```

加载自定义函数
Loading a custom function

```{r}
source(file = "gather_graph_node.R")
source(file = "gather_graph_edge.R")
```

# 输入文件的获得
# Obtaining the input file

如果你的数据已经整理成`very_easy_input.csv`的格式，就可以跳过这步，直接进入“输入文件预处理”。
If your data is already formatted as `very_easy_input.csv`, you can skip this step and proceed directly to "Input File Preprocessing."

先用clusterProfiler做KEGG的GSEA，然后用例图的形式展示结果。
First, use clusterProfiler to perform KEGG GSEA, then present the results using a case diagram.

```{r, eval=FALSE}
gsym.fc <- read.table("easy_input_rnk.txt", header = T)
dim(gsym.fc)
head(gsym.fc)

# 把gene symbol转换为ENTREZ ID
# Convert gene symbols to ENTREZ IDs
# 此处物种是人，其他物种的ID转换方法，请参考FigureYa52GOplot
# The species here is human. For ID conversion methods for other species, please refer to FigureYa52GOplot
gsym.id <- bitr(gsym.fc$SYMBOL, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")

#让基因名、ENTREZID、foldchange对应起来
# Align gene name, ENTREZ ID, and foldchange
gsym.fc.id <- merge(gsym.fc, gsym.id, by="SYMBOL", all=F)

#按照foldchange排序
# Sort by foldchange
gsym.fc.id.sorted <- gsym.fc.id[order(gsym.fc.id$logFC, decreasing = T),]

#获得ENTREZID、foldchange列表，做为GSEA的输入
# Obtain the ENTREZ ID and foldchange list as input for GSEA
id.fc <- gsym.fc.id.sorted$logFC
names(id.fc) <- gsym.fc.id.sorted$ENTREZID

#这一条语句就做完了KEGG的GSEA分析
# This single statement completes the KEGG GSEA analysis
kk <- gseKEGG(id.fc, organism = "hsa")
dim(kk)

# 把ENTREZ ID转为gene symbol，便于查看通路里的基因
# Convert the ENTREZ ID to a gene symbol to facilitate viewing genes within the pathway
kk.gsym <- setReadable(kk, 'org.Hs.eg.db', #物种
                    'ENTREZID')

# 可以用kk.gsym作为输入，用clusterProfiler画图
# Use kk.gsym as input to plot with clusterProfiler
# 用法看这里https://yulab-smu.github.io/clusterProfiler-book/chapter12.html
# See here for usage: https://yulab-smu.github.io/clusterProfiler-book/chapter12.html
# gsym.fc.l <- gsym.fc$logFC
# Names(gsym.fc.l) <- gsym.fc$SYMBOL
# Cnetplot(sortkk, foldChange = gsym.fc.l, circular = TRUE)

# 按照enrichment score从高到低排序，取前5（up）和后5（down）
# Sort by enrichment score, taking the top 5 (up) and bottom 5 (down)
# Sortkk <- kk.gsym[order(kk.gsym@result$enrichmentScore, decreasing = T),][c(1:5, (nrow(kk.gsym)-5):nrow(kk.gsym)),]
# 这里提取感兴趣的3个通路，数量太多拥挤的话不好看基因名
# Extract the three pathways of interest here. Too many gene names will make the gene names look cluttered.
sortkk <- kk.gsym[kk.gsym@result$Description %like% "DNA" |
                    kk.gsym@result$Description %like% "cycle" |
                    kk.gsym@result$Description %like% "p53",]

# 把富集分析结果整理为GOplot所需的格式
# Format the enrichment analysis results into the format required by GOplot
go <- data.frame(Category = "KEGG",
                 ID = sortkk$ID,
                 Term = sortkk$Description,
                 Genes = gsub("/", ", ", sortkk$core_enrichment),
                 adj_pval = sortkk$p.adjust)

# 基因变化倍数
# Fold change of genes
genelist <- data.frame(ID = gsym.fc.id$SYMBOL, logFC = gsym.fc.id$logFC)

# 把富集分析和倍数整合在一起
# Integrate the enrichment analysis and fold change
circ <- circle_dat(go, genelist)
head(circ)
# 可以用circ作为输入，用GOplot画图
# Use circ as input to plot with GOplot
# 用法看这里https://wencke.github.io/
# See here for usage: https://wencke.github.io/
# GOCircle(circ)

# 保存到文件
# Save to file
write.csv(circ[,c(3,5,6)],"very_easy_input.csv", quote = F, row.names = F)
```

# 输入文件预处理
# Input file preprocessing

very_easy_input.csv，这里以上面的富集分析结果为例，展示通路和通路里的基因变化倍数FC。三列依次是通路-基因-倍数，可以自由替换成“应用场景”里其他需要展示的信息。
very_easy_input.csv, using the above enrichment analysis results as an example, displays pathways and gene fold-change FC within them. The three columns are pathway-gene-fold-change, which can be freely replaced with other information required for the "application scenario."

gene_special.txt，要突出显示的基因。第一列是基因名，第二列是类型（例如基因家族信息）。
gene_special.txt, genes to be highlighted. The first column is the gene name, and the second column is the type (e.g., gene family information).

```{r}
df <- read.csv("very_easy_input.csv")
head(df)

geneSpecial <- read.table("gene_special.txt", header = T)
geneCol <- geneSpecial$Type
names(geneCol) <- geneSpecial$Gene
geneCol
```

图由两个部分组成，节点（node）和边（edge）。
A graph consists of two components: nodes and edges.

要从上面的数据框中采集节点和边的信息。
Node and edge information will be collected from the above data frame.

为此，我分别写了两个函数：`gather_graph_node()` 和 `gather_graph_edge()` 来完成这一个任务（前面已加载）。
To this end, I wrote two functions: `gather_graph_node()` and `gather_graph_edge()` to accomplish this task (previously loaded).

这两个函数的参数设置借鉴了 `treemap()` 的实现方式。
The parameter settings for these two functions are inspired by the implementation of `treemap()`.

  - `df`：一个数据框
  - `index`：一个索引项（分组项）
  - `value`：要采集的数值

- `df`: A data frame
- `index`: An index item (grouping item)
- `value`: The value to be collected

为了确保 `node.name` 的唯一性，在图中使用了长名，而把原有的名字放在 `node.short_name` 中去了。
To ensure the uniqueness of `node.name`, the long name is used in the graph, and the original name is placed in `node.short_name`.

`node.level` 则用来指示节点应该处于第几个圆环。
`node.level` is used to indicate the ring level of the node.

节点的属性统一以 `node` 作为前缀，而边的属性则以 `edge` 作为前缀。
Node attributes are prefixed with `node`, while edge attributes are prefixed with `edge`.

```{r}
nodes <- gather_graph_node(df, index = c("term", "genes"), value = "logFC", root="all")
edges <- gather_graph_edge(df, index = c("term", "genes"), root = "all")
nodes <- nodes %>% mutate_at(c("node.level","node.branch"),as.character)
head(nodes, 10)
head(edges, 10)

# 把要突出显示的基因类型信息加到nodes里
# Add the gene type information to be highlighted to nodes
nodes$color <- "normal"
nodes[nodes$node.short_name %in% geneSpecial$Gene,]$color <- geneCol[nodes[nodes$node.short_name %in% geneSpecial$Gene,]$node.short_name]
nodes[nodes$node.short_name %in% geneSpecial$Gene,]
nodes$color <- factor(nodes$color, levels = unique(nodes$color))

# 有了节点和边的数据，使用 `tbl_graph()` 便可以得到一个图。
# With the node and edge data, use `tbl_graph()` to create a graph.
graph <- tbl_graph(nodes, edges)
```

# 开始画图
# Start drawing the graph

## 自定义配色，直接出图
## Customize the color scheme and plot directly
