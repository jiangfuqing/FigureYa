---
title: "FigureYa27t-SNE_update"
author: "Zhougeng Xu; Ying Ge, Yijing Chen"
date: "2025-5-20"
output: html_document
---

![](hoptop.jpg)

# Academic Citation
If you use this code in your work or research, we kindly request that you cite our publication:

Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization Framework for Enhancing Biomedical Data Interpretation and Research Efficiency. iMetaMed. https://doi.org/10.1002/imm3.70005


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 需求描述
# Requirement description

用R做单细胞RNA-seq的t-SNE图。

Use R to draw a t-SNE plot for single-cell RNA-seq.

![](example.png)

出自<https://www.nature.com/articles/nature22973>

你可能会卡在两个问题上：R包安装和数据集的预处理。

本代码带你顺利解决这两个问题，画出t-SNE图，把细胞分类和候选marker基因输出到文件。

from<https://www.nature.com/articles/nature22973>

You may get stuck on two problems: R package installation and dataset preprocessing.

This code takes you through these two problems smoothly, drawing t-SNE plots, exporting cell classification and candidate marker genes to file.

# 应用场景
# Application scenario

场景一：单细胞测序的上百个细胞，识别亚群，找到marker基因；

场景二：上百个肿瘤样本，识别亚型，找到marker基因。像例图那样，用来划分甲基化亚型。

Scenario 1: Hundreds of cells from single cell sequencing, identify subpopulations, find marker genes;

Scenario 2: Hundreds of tumor samples, identify subtypes, find marker genes. Used to classify methylation subtypes like the example image.

# 环境设置
# Environment setting

安装R包`Seurat`。之前的版本对应2.x, 目前版本对应3.x.x.

Install the R package `Seurat`. The previous version corresponded to 2.x, the current version corresponds to 3.x.x.

```{r, warning=FALSE,message=FALSE}
source("install_dependencies.R")
# 加载Seurat
# loading Seurat
if (! require("Seurat")){
  install.packages('Seurat')
  library(Seurat)
} else{
  library(Seurat)
}
# 加载plyr
# loading plyr
if (! require(plyr)){
  install.packages("plyr")
  library(plyr)
} else{
  library(plyr)
}

library(ggplot2)
```

**注**: Windows系统用户安装会很顺利。

MacOS/Linux系统用户要有Root权限，或许会因为hdf5r安装失败而无法顺利安装，不要图省事，听报错的话，用`brew install hdf5`。

因为根据hdf5的源代码，它不支持最新的hdf5 1.10.2，最高只支持hdf5 1.10.0，所以请在root权限下根据源码安装。

**Note**: Windows users will have a smooth installation.

MacOS/Linux system users have to have Root privileges, perhaps because hdf5r installation failed to install smoothly, do not try to save time, listen to the words of the error report, use `brew install hdf5`.

Because according to the source code of hdf5, it does not support the latest hdf5 1.10.2, the highest only support hdf5 1.10.0, so please install it under root privileges according to the source code.

```bash
wget https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-1.10/hdf5-1.10.0/src/hdf5-1.10.0.tar.gz
tar xf hdf5-1.10.0.tar.gz
cd hdf5-1.10.0
./configure --prefix=/usr/local
make && sudo make install
```

# 数据预处理
# Data preprocessing

请先解压当前目录的下的tung.zip, 里面存放着测试数据集

输入数据是基于UMI的表达矩阵而不是count数据，其中数据集中的行表示基因，列表示细胞。

出自<https://www.nature.com/articles/srep39921>

Please unzip tung.zip in the current directory, which contains the test dataset.

The input data is based on UMI expression matrix instead of count data, where rows in the dataset represent genes and columns represent cells.

from<https://www.nature.com/articles/srep39921>

## 读取数据
## Read data

```{r, message=FALSE, warning=FALSE}
molecules <- read.delim("./tung/molecules.txt",header = TRUE,
           row.names = 1)
dim(molecules)
#查看前10个基因在前3个细胞中的表达量
#view the top 10 genes expressed in the top 3 cells
molecules[1:10,1:3]
```

## 创建Seurat对象
## Create Seurat object

数据初始化，并初步筛选

Data initialization and initial screening

```{r}
obj <- CreateSeuratObject(counts = molecules,
                   min.cells = 3, #筛选至少在3个细胞中表达的基因 screen genes expressed in at least 3 cells
                   min.features = 200) #筛选至少有200个基因表达的细胞 screen cells with at least 200 gene expressions
```

> 2.x版本是min.genes，现在改成了min.features，因为基因也是一种特征， 此外raw.data改成了counts

> Version 2.x was min.genes, now it is changed to min.features, because gene is also a feature, also raw.data is changed to counts

## 增加Seurat的元信息(metadata)
## Add metadata for Seurat

元信息存放在`obj@meta.data`中，可以是细胞的分组信息，所做处理等，需要自己提供。

此处包含3个人，各96个细胞，各3次重复。

Metadata is stored in `obj@meta.data`, it can be information about the grouping of cells, processing done, etc., you need to provide it yourself.

This contains 3 individuals, 96 cells each, 3 replicates each.

```{r, message=FALSE}
ann <- read.delim("./tung/annotation.txt", header = TRUE)
rownames(ann) <- ann$sample_id
head(ann)
summary(ann)
```

检查样品信息跟表达量矩阵的样品是否一致

Check whether the sample information is consistent with the sample in the expression matrix

```{r}
if (all(rownames(ann) %in% colnames(obj))){
  obj <- AddMetaData(obj, ann)
} else{
  warning("row names should be same to the items in object@cell.names")
}
```

## 过滤掉低质量细胞
## Filter out low quality cells

根据具体情况来确定标准，进行QC，过滤掉低质量的细胞，此处用`VlnPlot`探索可能的离群值

Determine the standards based on specific circumstances, conduct QC, and filter out low-quality cells. Use `VlnPlot` here to explore potential outliers.

```{r, warning=FALSE}
VlnPlot(obj, features = c("nCount_RNA","nFeature_RNA"), group.by = "orig.ident")
```

一般我们会过滤掉过低表达基因的细胞，上图中，你可以认为nCount_RNA低于`25000`、nFeature_RNA低于`6000`的细胞是低质量细胞。把这两个值写到下面过滤细胞的参数中：

Generally, we filter out cells with low expression genes. In the figure above, you can consider cells with nCount_RNA below `25000` and nFeature_RNA below `6000` as low-quality cells. Write these two values into the parameters for filtering cells below:

```{r}
obj <- subset(obj, subset = nCount_RNA  > 25000 &
                nFeature_RNA > 6000)
```

此处所用的数据实验深度足够，10X技术单细胞数据标准会不同。

The experimental depth of the data used here is sufficient, and the standardization of the 10X technology single-cell data will be different.

## 标准化
## Standardization

标准化这一步和混池RNA-seq类似，一般不会只使用raw count，而会用log标准化等方式降低其他干扰因素的影响。

The standardization step is similar to mixed-pool RNA-seq, in that raw counts are not the only thing used, and log normalization is used to reduce the effect of other confounding factors.

```{r, message=FALSE}
obj <- NormalizeData(
    object = obj,
    normalization.method = "LogNormalize",
    scale.factor = 10000
)
```

## 寻找细胞间变化明显的基因
## Find genes with significant cell-to-cell variation

直接使用全部基因进行后续分析对配置要求很高，而是选择那些在细胞中具有明显变化的基因。在降低资源消耗的同时还保证了结果的可靠性。

Directly using all genes for subsequent analysis is demanding in terms of configuration; instead, select those genes that have significant variation from cell to cell. This reduces resource consumption while ensuring the reliability of the results.

```{r, message=FALSE}
obj <- FindVariableFeatures(
    object = obj,
    mean.function = ExpMean, #计算x轴的值的方法 method for calculating the value of the x-axis
    dispersion.function = LogVMR, #计算y轴的值的方法 method for calculating the value of the y-axis
    do.plot = F,
    x.low.cutoff = 0.0125,
    x.high.cutoff = 3,
    y.cutoff = 0.5
)
```

## 处理混淆因子
## Deal with confounder factor

所谓的混淆因子(confounder factor) 指的就是目标因素（如实验处理）以外的因素对结果的影响， 比如说批次效应。这些因素掩盖了你真正想研究的目标，所以要尽可能排除。

The so-called confounder factor refers to the influence on the results by factors other than the target factor (such as experimental treatment), such as batch effects. These factors obscure the target you truly want to study, so they should be eliminated as much as possible.

```{r, message=FALSE, warning=FALSE}
obj <- ScaleData(
    object = obj,
    vars.to.regress = c("nCount_RNA")
)
```

## 线性降维（PCA）
## Linear dimensionality reduction (PCA)

后续会对细胞进行聚类，直接使用所有特征（即基因）会出现数据挖掘中的“维度爆炸”，即维度越高反而结果越差。因此我们需要用PCA进行线性降维，使用部分主成分代替所有基因进行后续的t-SNE和细胞聚类分析。

根据PCElbowPlot确定主成分个数，曲线变得平缓的横坐标。

这个主成分个数将用在下一部分的`pca_to_use =`参数中

Subsequently, the cells will be clustered. Directly using all features (i.e., genes) will lead to the "curse of dimensionality" in data mining, where higher dimensions result in poorer outcomes. Therefore, we need to perform linear dimensionality reduction using PCA, employing some principal components to replace all genes for subsequent t-SNE and cell clustering analysis.

The number of principal components is determined according to PCElbowPlot, and the curve become flattened in the horizontal coordinate.

This number of principal components will be used in the next section in the `pca_to_use =` parameter

```{r}
obj <- RunPCA(
    object = obj,
    pc.genes = obj@var.genes,
    do.print = FALSE
)
ElbowPlot(object = obj)
```

从图中可以看出：横坐标PC为14时，曲线趋近平缓，因此，此处定为14。

As can be seen from the figure: the curve tends to flatten out when the horizontal coordinate PC is 14, so it is set at 14 here.

## 细胞聚类
## Cell clustering

细胞聚类是单细胞分析的关键一步，毕竟大部分研究是想找到新的细胞分群、以前没有发现的细胞类型

Cell clustering is a crucial step in single-cell analysis; after all, most studies are trying to find new cellular subgroups, previously undiscovered cell types

```{r}
pca_to_use <- 14 #上一步主成分的个数 number of principal components in the previous step
obj <- FindNeighbors(obj, reduction = "pca",
                      dims = 1:pca_to_use)
obj <- FindClusters(object = obj,
                    resolution = 1.0)
```

## t-SNE非线性降维
## t-SNE nonlinear dimensionality reduction

```{r}
obj <- RunTSNE(
    object = obj,
    dims = 1:pca_to_use,
    do.fast = TRUE
)
```

# 开始画图
# Start drawing

按照细胞分群(`group.by="ident"`)进行着色

设置`pt_size`修改点的大小，修改`mycol`增加自定义颜色

Color according to cellular subgroups (`group.by="ident"`)

Set `pt_size` to modify point size, modify `mycol` to add custom colors
