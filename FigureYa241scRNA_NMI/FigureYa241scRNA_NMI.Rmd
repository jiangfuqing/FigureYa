---
title: "FigureYa241scRNA_NMI"
author: "Jianing Gao"
reviewer: "Ying Ge, Junyi Shen"
date: "2025-5-20"
output: html_document
---

# Academic Citation
If you use this code in your work or research, we kindly request that you cite our publication:

Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization Framework for Enhancing Biomedical Data Interpretation and Research Efficiency. iMetaMed. https://doi.org/10.1002/imm3.70005


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 需求描述
# Description of requirements

求用R实现图1E或者文章中别的Transcriptional homogeneity (NMI)图
Please use R to implement Figure 1E or other Transcriptional homogeneity (NMI) diagrams in the article.

![](example.png)

出自<https://linkinghub.elsevier.com/retrieve/pii/S1535610820303160>
From <https://linkinghub.elsevier.com/retrieve/pii/S1535610820303160>

Figure1. Increased Transcriptional Heterogeneity in Mouse LUAD Evolution Is Reproducible across Individual Tumors and Mice, but Cannot Fully Be Explained by Gene Copy Number Variation

(E) Reduced transcriptional homogeneity within time point with progression. Transcriptional heterogeneity is inversely proportional to the normalized mutual information (NMI) (y axis) between cells within in each sample type (genotype/time point combination, x axis), for either whole lung samples or microdissected single tumors. Boxplots: upper, median, and lower quartile of 1,000 bootstrap samples, of 50 cells each, from the indicated time point; whiskers: 1.5 interquartile range. *p < 0.05, **p < 0.01, ***p < 0.001 (STAR Methods).

![](method.png)

# 应用场景
# Application Scenario

利用单细胞数据评估同一(时间点)肿瘤样本的转录异质性
Using Single-Cell Data to Assess Transcriptional Heterogeneity in Tumor Samples at the Same Time Point

问题描述：同一个样本有若干个细胞，注意我们测的转录组是单细胞水平的，但是要评估是样本的转录组异质性。因此一个简单的想法是：
Problem: The same sample contains multiple cells. Note that the transcriptome we measure is at the single-cell level, but we want to assess the transcriptome heterogeneity of the sample. Therefore, a simple approach is:

- a)如果一个样本中的所有细胞，其距离的方差越大，则样本转录组异质性越高。据此，任何和方差关联的指标，其实都可以用来评估样本的转录组异质性。当然还有其它的指标，比如，
- b)我们可以评估样本内的cluster的多样性，同一样本的cluster越多样，该样本转录异质性越高，这个多样性可以用信息熵来计算。
- a) The greater the variance of the distances between all cells in a sample, the higher the sample's transcriptome heterogeneity. Therefore, any metric related to variance can be used to assess sample transcriptome heterogeneity. Of course, there are other metrics, such as
- b) We can assess the diversity of clusters within a sample. The more diverse the clusters within a sample, the higher the sample's transcriptional heterogeneity. This diversity can be calculated using information entropy.

- 本文作者则采取了互信息(可以理解为两个细胞转录组的相似性)来评估。对每一个样本的细胞进行不放回抽样(100 cells)，然后利用normalized mutual information (NMI)来衡量每对细胞之间的相似性。作者对每个样本进行100次抽样，每次抽样的NMI的中值作为该样本在此次抽样下的transcriptional homogeneity(转录同质性)。最后，作者采用了经验P值来进行显著性分析。
- The authors of this paper use mutual information (which can be understood as the similarity between two cell transcriptomes) for this assessment. Each sample was subsampled without replacement (100 cells), and the normalized mutual information (NMI) was used to measure the similarity between each pair of cells. The authors performed 100 subsamples for each sample, and the median NMI for each subsample was used as the transcriptional homogeneity for that sample. Finally, the authors used empirical P values ​​for significance analysis.

例文的Figure 2D和G，利用cNMF提取expression programs，并通过整合其它已发表的数据，利用Gene set analysis来推断expression programs的生物学意义。做法可参考FigureYa226scRNA_cNMF<https://k.koudai.com/T9Zd8Fu9>
In Figures 2D and 2G of the example paper, expression programs were extracted using cNMF. Gene set analysis was then used to infer the biological significance of these expression programs by integrating with other published data. For instructions, see FigureYa226scRNA_cNMF <https://k.koudai.com/T9Zd8Fu9>

# 环境设置
# Environment Setup

Using a domestic image installation package

```{r}
source("install_dependencies.R")

```

加载包
Load the package

```{r}
library(Seurat)
library(rhdf5)
library(tidyverse)
Sys.setenv(LANGUAGE = "en") #显示英文报错信息 #Display English error messages
options(stringsAsFactors = FALSE) #禁止chr转成factor #Disable conversion of chr to factor
```

# 0. 导入数据
# 0. Import data

输入数据的微云链接：<https://share.weiyun.com/GqYbpeGV>
Weiyun link for input data: <https://share.weiyun.com/GqYbpeGV>

## 0.1 cell meta信息
## 0.1 Cell metadata

```{r}
genes <- read.csv("data/GSE154989_mmLungPlate_fQC_geneTable.csv")
cells <- read.csv("data/GSE154989_mmLungPlate_fQC_smpTable.csv")
head(genes)
head(cells)
duplicated(genes$ensgID) %>% table
```

```{r}
cells.annot <- read.csv("data/GSE154989_mmLungPlate_fQC_dZ_annot_smpTable.csv")
cells.annot <- cells.annot %>%
  left_join(cells, by = "sampleID")
row.names(cells.annot) <- cells.annot$sampleID
head(cells.annot)
```

## 0.2 raw counts matrix

```{r}
filename <- "data/GSE154989_mmLungPlate_fQC_dSp_rawCount.h5"

h5ls(file = filename)

i <- h5read(filename, name = "i") %>% as.integer() %>% as.vector()
j <- h5read(filename, name = "j") %>% as.integer() %>% as.vector()
v <- h5read(filename, name = "v") %>% as.vector()

counts <- Matrix::sparseMatrix(i, j, x = v)
counts %>% dim
rownames(counts) <- genes$geneSymbol
colnames(counts) <- cells$sampleID
counts[1:5,1:5]
```

## 0.3 normalized matrix

```{r}
filename <- "data/GSE154989_mmLungPlate_fQC_dSp_normTPM.h5"

h5ls(file = filename)

i <- h5read(filename, name = "i") %>% as.integer() %>% as.vector()
j <- h5read(filename, name = "j") %>% as.integer() %>% as.vector()
v <- h5read(filename, name = "v") %>% as.vector()

TPM <- Matrix::sparseMatrix(i, j, x = v)
TPM %>% dim
TPM <- TPM %>% round(digits = 2)
rownames(TPM) <- genes$geneSymbol
colnames(TPM) <- cells$sampleID
TPM[1:5,1:5]
```

```{r}
seu <- CreateSeuratObject(counts = counts, meta.data = cells.annot)
seu[["RNA"]]@data <- TPM
seu[["tsne"]] <- CreateDimReducObject(embeddings = cells.annot[, c("tSNE_1", "tSNE_2")] %>% as.matrix(), assay = DefaultAssay(seu), key = "tSNE_")
seu[["phate"]] <- CreateDimReducObject(embeddings = cells.annot[, c("phate_1", "phate_2")] %>% as.matrix() * 50, assay = DefaultAssay(seu), key = "phate_")
Idents(seu) <- factor(seu$clusterK12)
DimPlot(seu, group.by = "clusterK12", reduction = "phate")
```


# 1. 选择基因集合(特征选择)
# 1. Selecting Gene Sets (Feature Selection)

> 选择不同cluster中的特征基因 Selecting Feature Genes in Different Clusters <br>
Using <br>
1) 100 differentially expressed genes per each of 12 subtype clusters and  <br>
2) top 100 NMF genes per each of 11 NMF programs <br>

## 1.1 cluster特异表达基因
## 1.1 Cluster-Specifically Expressed Genes

> 这里直接采用作者的计算结果 We use the author's calculation results directly here.

```{r}
dat <- readxl::read_excel("data/supp/tableS1.xlsx", sheet = "Summary")
head(dat)
de.genes <- unlist(head(dat, n=100)) %>% unique()
length(de.genes)
```

## 1.2 NMF中的特征基因
## 1.2 Feature Genes in NMF

> 这里也直接采用作者的计算结果 We also use the author's calculation results directly here.

```{r}
dat <- readxl::read_excel("data/supp/tableS2.xlsx", sheet = "Top weighted NMF topic markers")
head(dat)
nmf.genes <- lapply(colnames(dat)[2:ncol(dat)], function(xx) {
  dat %>% arrange(desc(get(xx))) %>% `[[`("Gene Name") %>% head(100)
})

nmf.genes <- unlist(nmf.genes) %>% unique()
length(nmf.genes)
```

```{r}
comb.genes <- c(de.genes, nmf.genes) %>% unique()
length(comb.genes)
```


# 2. 单细胞转录组离散化 Single cell transcriptome discretization

> We discretized expression per gene into 10 bins.

分箱算法: Binning algorithm <br>
1) 等长分箱(equal width intervals) <br>
2) 等频分箱(equal frequency intervals) <br>
3) 聚类分箱 Cluster binning <br>
4) 卡方分箱 Chi-square binning <br>
5) 决策树分箱 Decision tree binning <br>

> 这里尚不清楚作者采用了何种分箱算法，我们默认其采用的是`等长分箱` It's unclear what binning algorithm the author used, but we assume it uses equal width binning.

```{r, fig.width=5, fig.height=5}
row.idx <- rownames(seu[["RNA"]]@data) %in% comb.genes
dat <- seu[["RNA"]]@data[row.idx, ] %>% as.matrix()
dat[1:5, 1:5]

disc.expr <- apply(dat, 2, function(xx) {
  infotheo::discretize(xx, disc = "equalwidth", 10) %>% unlist()
})

rownames(disc.expr) <- rownames(dat)
dat[1:5,1:5]
disc.expr[1:5,1:5]

# 查看分箱结果
# View binning results
plot(dat[,1], col=disc.expr[,1])
```


# 3. 抽样 & 计算NMI
# 3. Sampling & Calculating NMI

> In order to account for differences in the number of cells across samples, we subsampled 100 cells from each time-point (or mouse) 100 times and calculated the median NMI across each within-timepoint sampled pair.

```{r}
cell.meta <- FetchData(seu, c("sampleID", "mouseID", "timesimple"))
head(cell.meta)
table(cell.meta$timesimple)
```

## 3.1 计算NMI (demo)
## 3.1 Calculate NMI (demo)

互信息(MI) Mutual Information (MI)
$$ I(X;Y)=\sum_x\sum_yp(x,y)log(\frac{p(x,y)}{p(x)p(y)}) $$
信息熵
$$ H(X)=\sum_xp(x)log(p(x)) $$

正则化的互信息(NMI) Normalized Mutual Information (NMI)
$$ NMI(X,Y)=\frac{I(X;Y)}{\sqrt{H(X)H(Y)}} $$

这里我们以一对细胞示例NMI的计算
Here, we use a pair of cells as an example to calculate NMI.

```{r}
require(entropy)

x <- disc.expr[, 1] # discretized transcriptional profile of cell 1
y <- disc.expr[, 2] # discretized transcriptional profile of cell 2

## 计算p(x), p(y)以及p(x,y)
## Calculate p(x), p(y) and p(x,y)
px <- table(x) %>% freqs.empirical()
py <- table(y) %>% freqs.empirical()
# joint distribusion
pxy <- cbind(x, y) %>% as.data.frame() %>% table %>% freqs.empirical()
## check codes
# rowSums(pxy) - px # all zeros
# colSums(pxy) - py # all zeros

## 信息熵
## Information entropy
Hx <- entropy.empirical(px, unit = "log2")
Hy <- entropy.empirical(py, unit = "log2")

## 互信息
## Mutual information
mi <- mi.empirical(pxy)

nmi <- mi/sqrt(Hx*Hy)

nmi
```

## 3.2 抽样计算NMI
## 3.2 Calculating NMI by Sampling

> In order to account for differences in the number of cells across samples, we subsampled 100 cells from each time-point (or mouse) 100 times and calculated the median NMI across each within-timepoint sampled pair.

这里是一个例子，用来计算同一(时间点)肿瘤样本抽样的100个细胞所有cell pairs的NMI的中值
Here is an example of calculating the median NMI for all cell pairs of 100 cells sampled from the same tumor sample (at the same time point).

```{r}
cells <- rownames(subset(cell.meta, timesimple == "01_T_early_ND"))

## all cell pairs
cell.pairs <- combn(
  x = sample(x = cells, size = 100, replace = FALSE),
  m = 2,
  simplify = F
) ## return list: length=C(100,2)=4960

## calculate NMI for all cell pairs: it takes around 30s for 4960 cell pairs
nmi <- function(x,y){
  pxy <- cbind(x, y) %>% as.data.frame() %>% table %>% freqs.empirical()
  px <- rowSums(pxy)
  py <- colSums(pxy)
  Hx <- entropy.empirical(px, unit = "log2")
  Hy <- entropy.empirical(py, unit = "log2")
  mi <- mi.empirical(pxy)
  return(mi/sqrt(Hx*Hy))
}

pbapply::pbsapply(cell.pairs, function(xx) {
  x <- disc.expr[, xx[1]]
  y <- disc.expr[, xx[2]]
  nmi(x,y)
}) %>% median()
```

将上述计算过程写成函数
Write the above calculation process as a function
